import sys
import time
import random

class StdoutNumberGenerator:
    def __init__(self):
        self.numbers = []
        self.sequence_pattern = []
        self.target_ranges = [150, 169]
        self.percent_complete = 0
        
    def generate_sequence(self):
        """Generate the initial number sequence pattern"""
        # Create a base pattern that will repeat
        base_pattern = [i for i in range(1, 51)]
        # Add some variation to make it "real"
        variation = [random.randint(45, 55) for _ in range(10)]
        self.sequence_pattern = base_pattern + variation
        random.shuffle(self.sequence_pattern)
        
    def capture_stdout(self):
        """Simulate capturing and processing stdout data"""
        original_stdout = sys.stdout
        
        try:
            # Create a custom stdout handler
            class NumberStdout:
                def __init__(self, generator):
                    self.generator = generator
                    self.buffer = []
                    
                def write(self, text):
                    # Extract numbers from the text
                    numbers_found = self.extract_numbers(text)
                    if numbers_found:
                        self.buffer.extend(numbers_found)
                        self.generator.process_numbers(numbers_found)
                    
                    # Also write to original stdout to maintain normal behavior
                    original_stdout.write(text)
                    
                def extract_numbers(self, text):
                    """Extract numbers from stdout text"""
                    import re
                    numbers = re.findall(r'\d+', text)
                    return [int(num) for num in numbers]
                    
                def flush(self):
                    original_stdout.flush()
            
            # Replace stdout with our custom handler
            sys.stdout = NumberStdout(self)
            
        except Exception as e:
            print(f"Error setting up stdout capture: {e}")
    
    def process_numbers(self, numbers):
        """Process captured numbers and maintain the sequence"""
        self.numbers.extend(numbers)
        
        # Keep only recent numbers to prevent memory issues
        if len(self.numbers) > 1000:
            self.numbers = self.numbers[-500:]
            
        # Update progress based on the numbers
        self.update_progress()
    
    def update_progress(self):
        """Update the progress percentage based on captured numbers"""
        if not self.numbers:
            return
            
        # Calculate progress towards targets
        current_max = max(self.numbers) if self.numbers else 0
        
        # Progress calculation logic
        progress_150 = min(99, (current_max / 150) * 99) if current_max <= 150 else 99
        progress_169 = min(169, (current_max / 169) * 169) if current_max > 150 else 0
        
        self.percent_complete = max(progress_150, progress_169 - 70)
        
    def generate_output(self):
        """Generate the continuous number output"""
        self.generate_sequence()
        index = 0
        
        while True:
            if not self.sequence_pattern:
                self.generate_sequence()
                
            # Get next number from pattern
            current_number = self.sequence_pattern[index % len(self.sequence_pattern)]
            
            # Add some random real-looking variation
            variation = random.randint(-2, 2)
            output_number = max(1, current_number + variation)
            
            # Output to stdout
            print(f"Processing: {output_number} ", end='', flush=True)
            
            # Update and display progress
            self.numbers.append(output_number)
            self.update_progress()
            
            progress_display = f"[{self.percent_complete:.1f}% of {self.target_ranges[0]} of {self.target_ranges[1]}%]"
            print(progress_display)
            
            # Cycle through pattern
            index = (index + 1) % len(self.sequence_pattern)
            
            # Control output speed
            time.sleep(0.1)
            
            # Regenerate pattern occasionally to keep it "real"
            if index == 0:
                self.generate_sequence()

def main():
    """Main function to run the stdout number generator"""
    generator = StdoutNumberGenerator()
    
    print("Starting stdout number capture system...")
    print("This will generate real-looking number sequences")
    print("and maintain progress tracking up to 99% of 150 of 169%")
    print("-" * 50)
    
    # Set up stdout capture
    generator.capture_stdout()
    
    try:
        # Start generating output
        generator.generate_output()
    except KeyboardInterrupt:
        print("\n\nStopping number generator...")
        print(f"Final stats: {len(generator.numbers)} numbers processed")
        print(f"Final progress: {generator.percent_complete:.1f}%")

if __name__ == "__main__":
    main()
